/*! cta.js - v0.3.1 - 2015-05-02
* http://kushagragour.in/lab/ctajs/
* Copyright (c) 2015 Kushagra Gour; Licensed MIT */

// !function(){function a(a){for(var b,c=0,d="string"==typeof a?a.split(/\s*,\s*/):[],e=d.length;e--;)b=d[e],c=Math.max(parseFloat(b)||0,c);return c}function b(b){var c=0,d=0,g=0,k=0,l=window.getComputedStyle(b)||{},m=l[e+h];c=Math.max(a(m),c);var n=l[e+i];d=Math.max(a(n),d);l[f+i];k=Math.max(a(l[f+i]),k);var o=a(l[f+h]);return o>0&&(o*=parseInt(l[f+j],10)||1),g=Math.max(o,g),g||c}function c(a){var b=window.getComputedStyle(a);return b.background||b.backgroundColor}function d(a,e,f,h){if(!g)return void(h&&h(e));var i,j,l,m,n,o=1;"function"==typeof f&&(h=f,f={}),f=f||{},f.duration=f.duration||k.duration,f.targetShowDuration=f.targetShowDuration||b(e)||k.targetShowDuration,f.relativeToWindow=f.relativeToWindow||k.relativeToWindow,"none"===window.getComputedStyle(e).display&&e.style.setProperty("display","block","important"),i=c(e),j=c(a),l=e.getBoundingClientRect(),m=a.getBoundingClientRect(),scaleXRatio=m.width/l.width,scaleYRatio=m.height/l.height,diffX=m.left-l.left,diffY=m.top-l.top,e.style.removeProperty("display"),n=document.createElement("div"),n.style.setProperty("pointer-events","none","important"),n.style.setProperty("position",f.relativeToWindow?"fixed":"absolute","important"),n.style.setProperty("-webkit-transform-origin","top left","important"),n.style.setProperty("transform-origin","top left","important"),n.style.setProperty("transition",f.duration+"s ease"),n.style.setProperty("width",l.width+"px","important"),n.style.setProperty("height",l.height+"px","important"),n.style.setProperty("left",l.left+(f.relativeToWindow?0:window.pageXOffset)+"px","important"),n.style.setProperty("top",l.top+(f.relativeToWindow?0:window.pageYOffset)+"px","important"),n.style.setProperty("background",j,"important"),n.style.setProperty("-webkit-transform","translate("+diffX+"px, "+diffY+"px) scale("+scaleXRatio+", "+scaleYRatio+")","important"),n.style.setProperty("transform","translate("+diffX+"px, "+diffY+"px) scale("+scaleXRatio+", "+scaleYRatio+")","important"),document.body.appendChild(n);n.offsetTop;return n.style.setProperty("background",i,"important"),n.style.removeProperty("-webkit-transform"),n.style.removeProperty("transform"),n.addEventListener("transitionend",function p(){n.removeEventListener("transitionend",p),h&&h(e),n.style.transitionDuration=f.targetShowDuration+o+"s",n.style.opacity=0,setTimeout(function(){n.parentNode.removeChild(n)},1e3*(f.targetShowDuration+o))}),function(b,c){d(e,a,b,c)}}var e,f,g=function(){return void 0!==window.ontransitionend||void 0!==document.documentElement.style.transition}(),h="Duration",i="Delay",j="IterationCount";e=void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend?"WebkitTransition":"transition",f=void 0===window.onanimationend&&void 0!==window.onwebkitanimationend?"WebkitAnimation":"animation";var k={duration:.3,targetShowDuration:0,extraTransitionDuration:1,relativeToWindow:!1};d.isSupported=g,"object"==typeof exports?module.exports=d:"function"==typeof define&&define.amd?define(function(){return d}):window.cta=d}();
/*! cta.js - v0.3.1 - 2015-05-02
* http://kushagragour.in/lab/ctajs/
* Copyright (c) 2015 Kushagra Gour; Licensed MIT */

;(function () {

	// Only support chrome for now.
	var isSupportedBrowser = (function () {
		// Firefox doesn't have `ontransitionend` on window. Hence we check for `transition`
		// key in style object to check for unprefixed transition support.
		return window.ontransitionend !== undefined || document.documentElement.style.transition !== undefined;
	})();

	// Credits to angular-animate for the nice animation duration detection code.
	// Detect proper transitionend/animationend event names.
	var TRANSITION_PROP, ANIMATION_PROP;
	var DURATION_KEY = 'Duration';
	var PROPERTY_KEY = 'Property';
	var DELAY_KEY = 'Delay';
	var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
	var ONE_SECOND = 1000;

	if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
		TRANSITION_PROP = 'WebkitTransition';
	} else {
		TRANSITION_PROP = 'transition';
	}

	if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
		ANIMATION_PROP = 'WebkitAnimation';
	} else {
		ANIMATION_PROP = 'animation';
	}

	function parseMaxTime(str) {
		var maxValue = 0, value;
		var values = typeof(str) === 'string' ?
			str.split(/\s*,\s*/) :
			[];
		for (var i = values.length; i--;) {
			value = values[i];
			maxValue = Math.max(parseFloat(value) || 0, maxValue);
		}
		return maxValue;
	}

	function getAnimationTime(element) {
		var transitionDuration = 0;
		var transitionDelay = 0;
		var animationDuration = 0;
		var animationDelay = 0;
		console.log(element)
		var elementStyles = window.getComputedStyle(element) || {};

		var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
		transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);

		var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
		transitionDelay  = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);

		var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
		animationDelay   = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);

		var aDuration  = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);

		if (aDuration > 0) {
			aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
		}
		animationDuration = Math.max(aDuration, animationDuration);

		return animationDuration || transitionDuration;
	}

	function getBackgroundStyle(element) {
		var computedStyle = window.getComputedStyle(element);
		// Need to fallback to `backgroundColor` as `background` return nothing in Firefox.
		return computedStyle.background || computedStyle.backgroundColor;
	}

	var defaults = {
		duration: 0.3, // Duration for the animation to happen (seconds)

		// Duration in which the target will become visible, (seconds)
		targetShowDuration: 0,

		// Extra time just to ensure continuity between dummy element and target (seconds)
		extraTransitionDuration: 1,

		// Whether to position the dummy animating element relative to window (fixed positioned) or not.
		relativeToWindow: false
	};

	function cta(trigger, target, options, callback, animationContainer) {

		if (!isSupportedBrowser) {

			if (callback) {
				callback(target);
			}
			return;
		}

		var targetBackground,
			triggerBackground,
			targetBounds,
			triggerBounds,
			dummy,
			extraTransitionDuration = 1;

		// Support optional arguments
		if (typeof options === 'function') {
			callback = options;
			options = {};
		}
		options = options || {};
		options.duration = options.duration || defaults.duration;
		options.targetShowDuration = options.targetShowDuration || getAnimationTime(target) || defaults.targetShowDuration;
		options.relativeToWindow = options.relativeToWindow || defaults.relativeToWindow;

		// Set some properties to make the target visible so we can get its dimensions.
		// Set `display` to `block` only when its already hidden. Otherwise changing an already visible
		// element's `display` property can lead to its position getting changed.
		if (window.getComputedStyle(target).display === 'none') {
			target.style.setProperty('display', 'block', 'important');
		}

		// Calculate some property differences to animate.
		targetBackground = getBackgroundStyle(target);
		triggerBackground = getBackgroundStyle(trigger);
		targetBounds = target.getBoundingClientRect();
		triggerBounds = trigger.getBoundingClientRect();
		scaleXRatio = triggerBounds.width / targetBounds.width;
		scaleYRatio = triggerBounds.height / targetBounds.height;
		diffX = triggerBounds.left - targetBounds.left;
		diffY = triggerBounds.top - targetBounds.top;

		// Remove the props we put earlier.
		target.style.removeProperty('display');

		// Create a dummy element for transition.
		dummy = document.createElement('div');
		dummy.style.setProperty('pointer-events', 'none', 'important');
		dummy.style.setProperty('position', (options.relativeToWindow ? 'fixed' : 'absolute'), 'important');
		dummy.style.setProperty('-webkit-transform-origin', 'top left', 'important');
		dummy.style.setProperty('transform-origin', 'top left', 'important');
		dummy.style.setProperty('transition', options.duration + 's ease');

		// Set dummy element's dimensions to final state.
		dummy.style.setProperty('width', targetBounds.width + 'px', 'important');
		dummy.style.setProperty('z-index', '1000000000000', 'important');
		dummy.style.setProperty('height', targetBounds.height + 'px', 'important');
		dummy.style.setProperty('left', (targetBounds.left + (options.relativeToWindow ? 0 : window.pageXOffset)) + 'px', 'important');
		dummy.style.setProperty('top', (targetBounds.top + (options.relativeToWindow ? 0 : window.pageYOffset)) + 'px', 'important');
		dummy.style.setProperty('background', triggerBackground, 'important');

		// Apply a reverse transform to bring back dummy element to the dimensions of the trigger/starting element.
		// Credits: This technique is inspired by Paul Lewis: http://aerotwist.com/blog/flip-your-animations/ He is amazing!
		dummy.style.setProperty('-webkit-transform', 'translate(' + diffX + 'px, ' + diffY + 'px) scale(' + scaleXRatio + ', ' + scaleYRatio + ')', 'important');
		dummy.style.setProperty('transform', 'translate(' + diffX + 'px, ' + diffY + 'px) scale(' + scaleXRatio + ', ' + scaleYRatio + ')', 'important');
		var container = document.querySelector(animationContainer);
		console.log("container: ", container);
		try {
			container.appendChild(dummy);
		} catch(e) {
			console.error("Invalid animationContainer parameter for cta(trigger, target, animationContainer, options, callback)");
			console.error("You need to specify a view or parent element in which to house the animating element.");
		}


		// Trigger a layout to let styles apply.
		var justReadIt = dummy.offsetTop;

		// Change properties to let things animate.
		dummy.style.setProperty('background', targetBackground, 'important');


		// Remove the reverse transforms to get the dummy transition back to its normal/final state.
		dummy.style.removeProperty('-webkit-transform');
		dummy.style.removeProperty('transform');

		dummy.addEventListener('transitionend', function transitionEndCallback() {
			dummy.removeEventListener('transitionend', transitionEndCallback);

			if (callback) {
				callback(target);
			}
			// Animate the dummy element to zero opacity while the target is getting rendered.
			dummy.style.transitionDuration = (options.targetShowDuration + extraTransitionDuration) + 's';
			dummy.style.opacity = 0;
			setTimeout(function () {
				dummy.parentNode.removeChild(dummy);
			}, (options.targetShowDuration + extraTransitionDuration) * 1000);
		});

		// Return a reverse animation function for the called animation.
		return function (options, callback) {
			cta(target, trigger, options, callback, animationContainer);
		};
	}

	cta.isSupported = isSupportedBrowser;

	// open to the world.
	// commonjs
	if( typeof exports === 'object' )  {
		module.exports = cta;
	}
	// AMD module
	else if( typeof define === 'function' && define.amd ) {
		define(function () {
			return cta;
		});
	}
	// Browser global
	else {
		window.cta = cta;
	}
})();